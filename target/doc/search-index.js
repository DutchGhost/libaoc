var searchIndex = {};
searchIndex["libaoc"] = {"doc":"This a library containing functions, structs, enums, traits and methods for common little problems while solving the Advent of Code.","items":[[5,"sort_biggest","libaoc","Returns a tuple, sorted by the max value. #Examples ``` extern crate libaoc; use libaoc::{sort_biggest};",null,null],[5,"sort_smallest","","Returns a tuple, sorted by the min value. #Examples ``` extern crate libaoc; use libaoc::{sort_smallest};",null,null],[0,"convert","","",null,null],[8,"TryConvert","libaoc::convert","This trait allows to convert a stream of `str`'s, into a stream or collection of type U. All safe versions return an Error when the conversion fails, the unsafe versions will panic instead. The unsafe versions are not concidered faster, but they safe one from matching or unwrapping the result. #Examples ``` extern crate libaoc;",null,null],[16,"Error","","The Errortype that gets returned on an error.",0,null],[16,"Iterable","","The Iterator that gets returned from try_convert_iter()",0,null],[16,"UnsafeIterable","","The Iterator that gets returned from unsafe_convert_iter",0,null],[10,"try_convert","","On succes, returns a vector of all completed conversions. When an error occures, returns an error instead.",0,{"inputs":[{"name":"self"}],"output":{"generics":["vec"],"name":"result"}}],[10,"try_convert_into_slice","","Tries to convert a stream of T into a slice of U. On an error, returns how many items where converted. #Examples]",0,null],[10,"try_convert_iter","","Returns an iterator over the converted items. Returns an error if an item can not be converted. Continue's after the error.",0,null],[10,"unsafe_convert","","On succes, returns a vector of all completed conversions. #Panic Panics when an error occures.",0,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[10,"unsafe_convert_iter","","Returns an iterator over the converted items. #Panic Panics when an error occures.",0,null],[8,"Convert","","This trait allows to convert a stream with items of type T into a stream or collection with items of type U.",null,null],[16,"Iterable","","The Iterator that gets returned from convert_iter()",1,null],[10,"convert","","Returns a vector of all completed conversions.",1,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[10,"convert_into_slice","","Converts the stream, and writes the items into `slice`. Returns how many elements where written to the slice.",1,null],[10,"convert_iter","","Returns an iterator that performs the conversions.",1,null],[0,"absolute","libaoc","",null,null],[8,"Absolute","libaoc::absolute","A trait to get the absolute value of a number. #Examples `extern crate libaoc; use libaoc::absolute::Absolute; fn main() { assert_eq!(10, (-10i32).abs()); assert_eq!(20, 20u32.abs()); }`",null,null],[10,"abs","","",2,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[0,"movement","libaoc","",null,null],[3,"Position","libaoc::movement","A position. Great to use in maps or graphs. #Examples ``` extern crate libaoc; use libaoc::movement::{Position, ManhattenDst}; use libaoc::absolute::Absolute; fn main() {     let tup = (-10i32, 21i32);     let pos = Position::new(-10i32, 21i32);     assert_eq!(Position::from(tup), pos);",null,null],[4,"Direction","","An enum to represent a direction. Is great to use in maps, or when 'following' some kind of line. Also supports an init variant. When the current variant is [`init`], using [`turn_right`] returns the variant [`right`]. When the current variant is [`init`], using [`turn_left`] returns the variant [`left`]. [`turn_right`]: enum.Direction.html#method.turn_right [`turn_left`]: enum.Direction.html#method.turn_left [`init`]: enum.Direction.html#variant.Init [`right`]: enum.Direction.html#variant.Right [`left`]: enum.Direction.html#variant.Left",null,null],[13,"Up","","",3,null],[13,"Down","","",3,null],[13,"Right","","",3,null],[13,"Left","","",3,null],[13,"Init","","",3,null],[8,"ManhattenDst","","Returns the manhatten distance of any Position with type N. A position is either a tuple, or the struct Position. the manhatten distance is the sum of the absolute values of a coordinate.",null,null],[10,"manhattendst","","Returns the `manhattendistance` of self.",4,{"inputs":[{"name":"self"}],"output":{"name":"n"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"direction"}],"output":{"name":"bool"}}],[11,"cmp","","",3,{"inputs":[{"name":"self"},{"name":"direction"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",3,{"inputs":[{"name":"self"},{"name":"direction"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"direction"}}],[11,"hash","","",3,null],[11,"init_left","","Initializes a direction facing to the left.",3,{"inputs":[],"output":{"name":"direction"}}],[11,"init_right","","Initializes a direction facing to the right.",3,{"inputs":[],"output":{"name":"direction"}}],[11,"init_up","","Initializes a direction facing up.",3,{"inputs":[],"output":{"name":"direction"}}],[11,"init_down","","Initializes a direction facing down.",3,{"inputs":[],"output":{"name":"direction"}}],[11,"init_init","","Initializes a direction that has no facing yet.",3,{"inputs":[],"output":{"name":"direction"}}],[11,"turn_right","","turns the direction to the right.",3,{"inputs":[{"name":"self"}],"output":{"name":"direction"}}],[11,"turn_left","","turns the direction to the left.",3,{"inputs":[{"name":"self"}],"output":{"name":"direction"}}],[11,"reverse","","Reverses the current direction. #Panic Panics whenever the current direction is `Init`.",3,{"inputs":[{"name":"self"}],"output":{"name":"direction"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"position"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"self"},{"name":"position"}],"output":{"name":"bool"}}],[11,"cmp","","",5,{"inputs":[{"name":"self"},{"name":"position"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",5,{"inputs":[{"name":"self"},{"name":"position"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",5,{"inputs":[{"name":"self"},{"name":"position"}],"output":{"name":"bool"}}],[11,"le","","",5,{"inputs":[{"name":"self"},{"name":"position"}],"output":{"name":"bool"}}],[11,"gt","","",5,{"inputs":[{"name":"self"},{"name":"position"}],"output":{"name":"bool"}}],[11,"ge","","",5,{"inputs":[{"name":"self"},{"name":"position"}],"output":{"name":"bool"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"position"}}],[11,"hash","","",5,null],[11,"add","","",5,null],[11,"add","","",5,null],[11,"sub","","",5,null],[11,"sub","","",5,null],[11,"new","","Returns a new Position.",5,{"inputs":[{"name":"n"},{"name":"n"}],"output":{"name":"position"}}],[11,"change","","Changes the position with `steps` based on the direction. If the direction is facing down, `y` is incremented, if the direction if facing up, `y` is decremented. If the direction is [`Direction::Init`], no update is made. #Examples ``` extern crate libaoc; use libaoc::movement::{Position, Direction}; fn main() {     let mut pos = Position::new(0, 0);     let dir = Direction::init_up();",5,{"inputs":[{"name":"self"},{"name":"direction"},{"name":"n"}],"output":null}],[11,"rev_change","","Same as [`change`], but now increments `y` when facing upwards, and decrements `y` when facing downwards. #Examples ``` extern crate libaoc; use libaoc::movement::{Direction, Position}; fn main() {     let mut pos = Position::new(0, 0);     let dir = Direction::init_up();",5,{"inputs":[{"name":"self"},{"name":"direction"},{"name":"n"}],"output":null}],[11,"is_adjecent","","Check whether self and `other` are adjecent. That is, if the absolute x value and the absolute y value after subtracting `self` from `other` is either (1, 0), (0, 1) or (1, 1). #Examples ``` extern crate libaoc; use libaoc::movement::Position; use libaoc::absolute::Absolute; fn main() {     let pos1 = Position::new(5, 6);     let pos2 = Position::new(6, 7);",5,{"inputs":[{"name":"self"},{"name":"position"}],"output":{"name":"bool"}}],[11,"increment_y","","Adds `steps` to y. #Examples `extern crate libaoc; use libaoc::movement::Position; fn main() { let mut pos = Position::new(0, 0); pos.increment_y(10); assert_eq!(Position::new(0, 10), pos); }`",5,{"inputs":[{"name":"self"},{"name":"n"}],"output":null}],[11,"decrement_y","","Subtracts `steps` from y.",5,{"inputs":[{"name":"self"},{"name":"n"}],"output":null}],[11,"increment_x","","Adds `steps` to x.",5,{"inputs":[{"name":"self"},{"name":"n"}],"output":null}],[11,"decrement_x","","Subtracts `steps` from x.",5,{"inputs":[{"name":"self"},{"name":"n"}],"output":null}],[11,"get_ref_x","","Returns a reference to the current x value.",5,{"inputs":[{"name":"self"}],"output":{"name":"n"}}],[11,"get_ref_y","","Returns a reference to the current y value.",5,{"inputs":[{"name":"self"}],"output":{"name":"n"}}],[11,"get_ref","","Returns a tuple of &x, &y.",5,null],[11,"to_tuple","","Clones x and y into a tuple.",5,null],[11,"abs","","",5,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",5,null],[11,"into","","",5,null],[11,"manhattendst","","",5,{"inputs":[{"name":"self"}],"output":{"name":"n"}}],[8,"MinMax","libaoc","2 functions to 'sort' a tuple. `minmax` returns the tuple in ascending order, `maxmin` in descending order. #Examples ``` extern crate libaoc; use libaoc::MinMax; fn main() {     let mut tup = (20, 10);     let mutborrow = &mut tup;",null,null],[10,"minmax","","",6,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"maxmin","","",6,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[14,"apply","","Applies any given operator to any given tuple. #Examples ``` #[macro_use(apply)] extern crate libaoc;",null,null],[14,"sub","","Subtracts all items in a tuple. #Examples ``` #[macro_use(sub, apply)] extern crate libaoc;",null,null],[14,"add","","Adds all items in a tuple. #Examples ``` #[macro_use(add, apply)] extern crate libaoc;",null,null],[14,"div","","Divides all items in a tuple. Panics if divided by 0. #Examples ``` #[macro_use(div, apply)] extern crate libaoc;",null,null],[14,"mul","","Multiplies all items in a tuple. #Examples ``` #[macro_use(mul, apply)] extern crate libaoc;",null,null],[14,"rem","","'Remainders' all items in a tuple. #Examples ``` #[macro_use(rem, apply)] extern crate libaoc;",null,null],[14,"noop","","This macro is used to generate `noop` functions. Works only on tuples, but is great to use in functional programming when you just need to pass a `noop` function into another function. #Examples ``` #[macro_use] extern crate libaoc; fn main() {     let f = noop!(&mut (i64, i64));     assert_eq!((10, 10), take_func(f, (10, 10)));",null,null]],"paths":[[8,"TryConvert"],[8,"Convert"],[8,"Absolute"],[4,"Direction"],[8,"ManhattenDst"],[3,"Position"],[8,"MinMax"]]};
initSearch(searchIndex);
